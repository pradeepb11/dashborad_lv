import { Injectable } from '@angular/core';
import { dayjsRef } from '../common/dayjs/dayjs.ref';
import * as i0 from "@angular/core";
import * as i1 from "../common/services/utils/utils.service";
export class MonthCalendarService {
    constructor(utilsService) {
        this.utilsService = utilsService;
        this.DEFAULT_CONFIG = {
            allowMultiSelect: false,
            yearFormat: 'YYYY',
            format: 'MM-YYYY',
            isNavHeaderBtnClickable: false,
            monthBtnFormat: 'MMM',
            multipleYearsNavigateBy: 10,
            showMultipleYearsNavigation: false,
            unSelectOnClick: true,
            numOfMonthRows: 3
        };
    }
    getConfig(config) {
        const _config = {
            ...this.DEFAULT_CONFIG,
            ...this.utilsService.clearUndefined(config)
        };
        MonthCalendarService.validateConfig(_config);
        this.utilsService.convertPropsToDayjs(_config, _config.format, ['min', 'max']);
        return _config;
    }
    generateYear(config, year, selected = null) {
        let index = year.startOf('year');
        return this.utilsService.createArray(config.numOfMonthRows).map(() => {
            return this.utilsService.createArray(12 / config.numOfMonthRows).map(() => {
                const date = dayjsRef(index);
                const month = {
                    date,
                    selected: !!selected.find(s => index.isSame(s, 'month')),
                    currentMonth: index.isSame(dayjsRef(), 'month'),
                    disabled: this.isMonthDisabled(date, config),
                    text: this.getMonthBtnText(config, date)
                };
                index = index.add(1, 'month');
                return month;
            });
        });
    }
    isMonthDisabled(date, config) {
        if (config.isMonthDisabledCallback) {
            return config.isMonthDisabledCallback(date);
        }
        if (config.min && date.isBefore(config.min, 'month')) {
            return true;
        }
        return !!(config.max && date.isAfter(config.max, 'month'));
    }
    shouldShowLeft(min, currentMonthView) {
        return min ? min.isBefore(currentMonthView, 'year') : true;
    }
    shouldShowRight(max, currentMonthView) {
        return max ? max.isAfter(currentMonthView, 'year') : true;
    }
    getHeaderLabel(config, year) {
        if (config.yearFormatter) {
            return config.yearFormatter(year);
        }
        return year.format(config.yearFormat);
    }
    getMonthBtnText(config, month) {
        if (config.monthBtnFormatter) {
            return config.monthBtnFormatter(month);
        }
        return month.format(config.monthBtnFormat);
    }
    getMonthBtnCssClass(config, month) {
        if (config.monthBtnCssClassCallback) {
            return config.monthBtnCssClassCallback(month);
        }
        return '';
    }
    static validateConfig(config) {
        if (config.numOfMonthRows < 1 || config.numOfMonthRows > 12 || !Number.isInteger(12 / config.numOfMonthRows)) {
            throw new Error('numOfMonthRows has to be between 1 - 12 and divide 12 to integer');
        }
    }
}
MonthCalendarService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: MonthCalendarService, deps: [{ token: i1.UtilsService }], target: i0.ɵɵFactoryTarget.Injectable });
MonthCalendarService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: MonthCalendarService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.1", ngImport: i0, type: MonthCalendarService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.UtilsService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9udGgtY2FsZW5kYXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25nMi1kYXRlLXBpY2tlci9zcmMvbGliL21vbnRoLWNhbGVuZGFyL21vbnRoLWNhbGVuZGFyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQU16QyxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sMkJBQTJCLENBQUM7OztBQU9uRCxNQUFNLE9BQU8sb0JBQW9CO0lBYS9CLFlBQW9CLFlBQTBCO1FBQTFCLGlCQUFZLEdBQVosWUFBWSxDQUFjO1FBWnJDLG1CQUFjLEdBQWlDO1lBQ3RELGdCQUFnQixFQUFFLEtBQUs7WUFDdkIsVUFBVSxFQUFFLE1BQU07WUFDbEIsTUFBTSxFQUFFLFNBQVM7WUFDakIsdUJBQXVCLEVBQUUsS0FBSztZQUM5QixjQUFjLEVBQUUsS0FBSztZQUNyQix1QkFBdUIsRUFBRSxFQUFFO1lBQzNCLDJCQUEyQixFQUFFLEtBQUs7WUFDbEMsZUFBZSxFQUFFLElBQUk7WUFDckIsY0FBYyxFQUFFLENBQUM7U0FDbEIsQ0FBQztJQUdGLENBQUM7SUFFRCxTQUFTLENBQUMsTUFBNEI7UUFDcEMsTUFBTSxPQUFPLEdBQWlDO1lBQzVDLEdBQUcsSUFBSSxDQUFDLGNBQWM7WUFDdEIsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUM7U0FDNUMsQ0FBQztRQUVGLG9CQUFvQixDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM3QyxJQUFJLENBQUMsWUFBWSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFFL0UsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQztJQUVELFlBQVksQ0FB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QUUsS0FBWTtRQUM1RCxJQUFJLE1BQU0sQ0FBQyx3QkFBd0IsRUFBRTtZQUNuQyxPQUFPLE1BQU0sQ0FBQyx3QkFBd0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMvQztRQUVELE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQztJQUVPLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBb0M7UUFDaEUsSUFBSSxNQUFNLENBQUMsY0FBYyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsY0FBYyxHQUFHLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRSxHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUMsRUFBRTtZQUM1RyxNQUFNLElBQUksS0FBSyxDQUFDLGtFQUFrRSxDQUFDLENBQUM7U0FDckY7SUFDSCxDQUFDOztpSEFqR1Usb0JBQW9CO3FIQUFwQixvQkFBb0IsY0FGbkIsTUFBTTsyRkFFUCxvQkFBb0I7a0JBSGhDLFVBQVU7bUJBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHtVdGlsc1NlcnZpY2V9IGZyb20gJy4uL2NvbW1vbi9zZXJ2aWNlcy91dGlscy91dGlscy5zZXJ2aWNlJztcbmltcG9ydCB7SU1vbnRofSBmcm9tICcuL21vbnRoLm1vZGVsJztcbmltcG9ydCB7SU1vbnRoQ2FsZW5kYXJDb25maWcsIElNb250aENhbGVuZGFyQ29uZmlnSW50ZXJuYWx9IGZyb20gJy4vbW9udGgtY2FsZW5kYXItY29uZmlnJztcbmltcG9ydCB7RGF5anN9IGZyb20gJ2RheWpzJztcbmltcG9ydCB7ZGF5anNSZWZ9IGZyb20gJy4uL2NvbW1vbi9kYXlqcy9kYXlqcy5yZWYnO1xuXG5cblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgTW9udGhDYWxlbmRhclNlcnZpY2Uge1xuICByZWFkb25seSBERUZBVUxUX0NPTkZJRzogSU1vbnRoQ2FsZW5kYXJDb25maWdJbnRlcm5hbCA9IHtcbiAgICBhbGxvd011bHRpU2VsZWN0OiBmYWxzZSxcbiAgICB5ZWFyRm9ybWF0OiAnWVlZWScsXG4gICAgZm9ybWF0OiAnTU0tWVlZWScsXG4gICAgaXNOYXZIZWFkZXJCdG5DbGlja2FibGU6IGZhbHNlLFxuICAgIG1vbnRoQnRuRm9ybWF0OiAnTU1NJyxcbiAgICBtdWx0aXBsZVllYXJzTmF2aWdhdGVCeTogMTAsXG4gICAgc2hvd011bHRpcGxlWWVhcnNOYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICB1blNlbGVjdE9uQ2xpY2s6IHRydWUsXG4gICAgbnVtT2ZNb250aFJvd3M6IDNcbiAgfTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHV0aWxzU2VydmljZTogVXRpbHNTZXJ2aWNlKSB7XG4gIH1cblxuICBnZXRDb25maWcoY29uZmlnOiBJTW9udGhDYWxlbmRhckNvbmZpZyk6IElNb250aENhbGVuZGFyQ29uZmlnSW50ZXJuYWwge1xuICAgIGNvbnN0IF9jb25maWcgPSA8SU1vbnRoQ2FsZW5kYXJDb25maWdJbnRlcm5hbD57XG4gICAgICAuLi50aGlzLkRFRkFVTFRfQ09ORklHLFxuICAgICAgLi4udGhpcy51dGlsc1NlcnZpY2UuY2xlYXJVbmRlZmluZWQoY29uZmlnKVxuICAgIH07XG5cbiAgICBNb250aENhbGVuZGFyU2VydmljZS52YWxpZGF0ZUNvbmZpZyhfY29uZmlnKTtcbiAgICB0aGlzLnV0aWxzU2VydmljZS5jb252ZXJ0UHJvcHNUb0RheWpzKF9jb25maWcsIF9jb25maWcuZm9ybWF0LCBbJ21pbicsICdtYXgnXSk7XG5cbiAgICByZXR1cm4gX2NvbmZpZztcbiAgfVxuXG4gIGdlbmVyYXRlWWVhcihjb25maWc6IElNb250aENhbGVuZGFyQ29uZmlnLCB5ZWFyOiBEYXlqcywgc2VsZWN0ZWQ6IERheWpzW10gPSBudWxsKTogSU1vbnRoW11bXSB7XG4gICAgbGV0IGluZGV4ID0geWVhci5zdGFydE9mKCd5ZWFyJyk7XG5cbiAgICByZXR1cm4gdGhpcy51dGlsc1NlcnZpY2UuY3JlYXRlQXJyYXkoY29uZmlnLm51bU9mTW9udGhSb3dzKS5tYXAoKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMudXRpbHNTZXJ2aWNlLmNyZWF0ZUFycmF5KDEyIC8gY29uZmlnLm51bU9mTW9udGhSb3dzKS5tYXAoKCkgPT4ge1xuICAgICAgICBjb25zdCBkYXRlID0gZGF5anNSZWYoaW5kZXgpO1xuICAgICAgICBjb25zdCBtb250aCA9IHtcbiAgICAgICAgICBkYXRlLFxuICAgICAgICAgIHNlbGVjdGVkOiAhIXNlbGVjdGVkLmZpbmQocyA9PiBpbmRleC5pc1NhbWUocywgJ21vbnRoJykpLFxuICAgICAgICAgIGN1cnJlbnRNb250aDogaW5kZXguaXNTYW1lKGRheWpzUmVmKCksICdtb250aCcpLFxuICAgICAgICAgIGRpc2FibGVkOiB0aGlzLmlzTW9udGhEaXNhYmxlZChkYXRlLCBjb25maWcpLFxuICAgICAgICAgIHRleHQ6IHRoaXMuZ2V0TW9udGhCdG5UZXh0KGNvbmZpZywgZGF0ZSlcbiAgICAgICAgfTtcblxuICAgICAgICBpbmRleCA9IGluZGV4LmFkZCgxLCAnbW9udGgnKTtcblxuICAgICAgICByZXR1cm4gbW9udGg7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlzTW9udGhEaXNhYmxlZChkYXRlOiBEYXlqcywgY29uZmlnOiBJTW9udGhDYWxlbmRhckNvbmZpZykge1xuICAgIGlmIChjb25maWcuaXNNb250aERpc2FibGVkQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjb25maWcuaXNNb250aERpc2FibGVkQ2FsbGJhY2soZGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5taW4gJiYgZGF0ZS5pc0JlZm9yZShjb25maWcubWluLCAnbW9udGgnKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhKGNvbmZpZy5tYXggJiYgZGF0ZS5pc0FmdGVyKGNvbmZpZy5tYXgsICdtb250aCcpKTtcbiAgfVxuXG4gIHNob3VsZFNob3dMZWZ0KG1pbjogRGF5anMsIGN1cnJlbnRNb250aFZpZXc6IERheWpzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG1pbiA/IG1pbi5pc0JlZm9yZShjdXJyZW50TW9udGhWaWV3LCAneWVhcicpIDogdHJ1ZTtcbiAgfVxuXG4gIHNob3VsZFNob3dSaWdodChtYXg6IERheWpzLCBjdXJyZW50TW9udGhWaWV3OiBEYXlqcyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBtYXggPyBtYXguaXNBZnRlcihjdXJyZW50TW9udGhWaWV3LCAneWVhcicpIDogdHJ1ZTtcbiAgfVxuXG4gIGdldEhlYWRlckxhYmVsKGNvbmZpZzogSU1vbnRoQ2FsZW5kYXJDb25maWcsIHllYXI6IERheWpzKTogc3RyaW5nIHtcbiAgICBpZiAoY29uZmlnLnllYXJGb3JtYXR0ZXIpIHtcbiAgICAgIHJldHVybiBjb25maWcueWVhckZvcm1hdHRlcih5ZWFyKTtcbiAgICB9XG5cbiAgICByZXR1cm4geWVhci5mb3JtYXQoY29uZmlnLnllYXJGb3JtYXQpO1xuICB9XG5cbiAgZ2V0TW9udGhCdG5UZXh0KGNvbmZpZzogSU1vbnRoQ2FsZW5kYXJDb25maWcsIG1vbnRoOiBEYXlqcyk6IHN0cmluZyB7XG4gICAgaWYgKGNvbmZpZy5tb250aEJ0bkZvcm1hdHRlcikge1xuICAgICAgcmV0dXJuIGNvbmZpZy5tb250aEJ0bkZvcm1hdHRlcihtb250aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vbnRoLmZvcm1hdChjb25maWcubW9udGhCdG5Gb3JtYXQpO1xuICB9XG5cbiAgZ2V0TW9udGhCdG5Dc3NDbGFzcyhjb25maWc6IElNb250aENhbGVuZGFyQ29uZmlnLCBtb250aDogRGF5anMpOiBzdHJpbmcge1xuICAgIGlmIChjb25maWcubW9udGhCdG5Dc3NDbGFzc0NhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY29uZmlnLm1vbnRoQnRuQ3NzQ2xhc3NDYWxsYmFjayhtb250aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgdmFsaWRhdGVDb25maWcoY29uZmlnOiBJTW9udGhDYWxlbmRhckNvbmZpZ0ludGVybmFsKTogdm9pZCB7XG4gICAgaWYgKGNvbmZpZy5udW1PZk1vbnRoUm93cyA8IDEgfHwgY29uZmlnLm51bU9mTW9udGhSb3dzID4gMTIgfHwgIU51bWJlci5pc0ludGVnZXIoMTIgLyBjb25maWcubnVtT2ZNb250aFJvd3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bU9mTW9udGhSb3dzIGhhcyB0byBiZSBiZXR3ZWVuIDEgLSAxMiBhbmQgZGl2aWRlIDEyIHRvIGludGVnZXInKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==